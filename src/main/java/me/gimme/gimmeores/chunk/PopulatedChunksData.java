package me.gimme.gimmeores.chunk;

import org.bukkit.Server;
import org.bukkit.World;
import org.jetbrains.annotations.NotNull;

import java.awt.*;
import java.util.*;

/**
 * Holds the data of chunks that have been populated and should not be populated again.
 */
public class PopulatedChunksData {
    private static class WorldInfo {
        private String name;
        private Set<Point> chunks = new HashSet<>();

        private WorldInfo(@NotNull String name) {
            this.name = name;
        }
    }

    private String seed = UUID.randomUUID().hashCode() + "";
    private Map<@NotNull UUID, @NotNull WorldInfo> worlds = new HashMap<>();

    /**
     * @return the chunk coordinates of the chunks that have been populated
     * @param world the world to get the populated chunks for
     */
    public Set<Point> getPopulatedChunks(@NotNull World world) {
        return worlds.computeIfAbsent(world.getUID(), k -> new WorldInfo(world.getName())).chunks;
    }

    /**
     * @return the ID for the specified world
     * @param world the world to get the ID for
     */
    public String getId(@NotNull World world) {
        return world.getUID().toString();
    }

    /**
     * Returns the seed generated for the specified world.
     * This is not the same as {@link World#getSeed()}.
     * The seed is generated by a combination of this plugin's seed and the UUID of the world,
     * meaning a reset of the world's uid.dat file or this plugin's populated-chunks.json file will generate a new seed.
     *
     * @param world the world to get the seed for
     * @return the seed generated for the specified world
     */
    public long getSeed(@NotNull World world) {
        return bitwiseConcat(this.seed.hashCode(), world.getUID().hashCode());
    }

    /**
     * Updates world names and removes old worlds.
     * @param server the server
     */
    public void cleanupWorlds(@NotNull Server server) {
        Set<UUID> toRemove = new HashSet<>();

        for (Map.Entry<UUID, WorldInfo> entry : this.worlds.entrySet()) {
            World world = server.getWorlds().stream()
                    .filter(w -> w.getUID().equals(entry.getKey()))
                    .findFirst()
                    .orElse(null);
            if (world == null) {
                toRemove.add(entry.getKey());
            } else {
                entry.getValue().name = world.getName();
            }
        }

        toRemove.forEach(uuid -> this.worlds.remove(uuid));
    }

    /**
     * @return a bitwise concatenation of the two integers into a long
     * @param a the left bits
     * @param b the right bits
     *
     */
    private static long bitwiseConcat(int a, int b) {
        return (a << Integer.SIZE) + b;
    }
}
